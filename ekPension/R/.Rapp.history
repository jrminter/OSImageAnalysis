source("/Users/jminter/Documents/doc/work/R/tutPCA/tutPCA.R")
source("/Users/jrminter/work/R/tutPCA/tutPCA.R")
?rnorm
source("/Users/jrminter/work/R/tutPCA/tutPCA.R")
?points
source("/Users/jrminter/work/R/tutPCA/tutPCA.R")
?points
source("/Users/jrminter/work/R/tutPCA/tutPCA.R")
?matrix
a
b
m <- c(a,b)
m
rm(m)
data <- data.frame(x=a,y=b)
data
m <- as.matrix(data)
m
data <- data.frame(x=a,y=b)
?cos
ra <- 75 * pi /180
ra
ra <- 75 * pi /180#
R <- matrix(c(cos(ra), -sin(ra), sin(ra), cos(ra)), nrow=2))
ra <- 75 * pi /180#
R <- matrix(c(cos(ra), -sin(ra), sin(ra), cos(ra)), nrow=2)
R
G <- R*t(M)
G <- R*t(m)
G <- R*m
size(r)
summary(R)
class(R)
nrow(R)
nrow(m)
nclol(m)
ncol(m)
ncol(R)
?sapply
library(matlab)
?matlab
??matlab
?rapply
?for
)
?for
}
help
v <- matrix(c(1., 2.), nrow=1)
v
v <- matrix(c(1., 2.), nrow=2)
v
G <- R*V
G <- R*v
nrow(R)
G <- R*t(v)
R*v
nrow(R)
ncol(R)
nrow(v)
ncol(v)
R
v
R*v
R %*% v
v.r <- R %*% v
v.r[1,1]
v.r[1,2]
v.r[2]
v.r[1]
rot.coord <- function(x,y, angle.deg)#
{#
  l <- length(x)#
  ra <- angle.deg * pi /180#
  x.r <- vector('numeric')#
  x.y <- vector('numeric')#
  R <- matrix(c(cos(ra), -sin(ra), sin(ra), cos(ra)), nrow=2)#
  for (i in 1:l)#
  {#
    v <- matrix(c(x[i], y[i]), nrow=2)#
    v.r <- R %*% v#
    x.r <- append(x.r, v.r[1])#
    y.r <- append(y.r, v.r[2])   #
  }#
  rot <- data.frame(x=x.r, y=y.r)#
  rot#
}
dr <- rot.coord(a,b, 75.0)
rot.coord <- function(x,y, angle.deg)#
{#
  l <- length(x)#
  ra <- angle.deg * pi /180#
  x.r <- vector('numeric')#
  y.r <- vector('numeric')#
  R <- matrix(c(cos(ra), -sin(ra), sin(ra), cos(ra)), nrow=2)#
  for (i in 1:l)#
  {#
    v <- matrix(c(x[i], y[i]), nrow=2)#
    v.r <- R %*% v#
    x.r <- append(x.r, v.r[1])#
    y.r <- append(y.r, v.r[2])   #
  }#
  rot <- data.frame(x=x.r, y=y.r)#
  rot#
}
dr <- rot.coord(a,b, 75.0)
dr
plot(dr)
rm(list=ls())
source("/Users/jrminter/work/R/tutPCA/tutPCA.R")
?rnorm
eigen(d.r)
source("/Users/jrminter/work/R/tutPCA/tutPCA.R")
?data
data("heptathalon", package="HSAUR2")
data("heptathlon", package="HSAUR2")
heptathlon$hurdles <- max(heptathlon$hurdles)-heptathlon$hurdles
heptathlon$run200m <- max(heptathlon$run200m)-heptathlon$run200m
heptathlon$run800m <- max(heptathlon$run800m)-heptathlon$run800m
score <- which(colnames(heptathlon)=="score")
plot(heptathlon[,-score])
round(cor(heptathlon[,-score]), 2)
heptathlon <- heptathlon[-grep("PNG",rownames(heptathlon)),]
round(cor(heptathlon[,-score]), 2)
heptathlon_pca <- prcomp(heptathlon[,-score], scale=TRUE)
print(heptathlon_pca)
score <-which(colnames(heptathlon)=="score")
plot(heptathlon[,-score])
print(heptathlon_pca)
summary(heptathlon_pca)
heptathlon_cor <- cor(heptathlon[,-score])
heptathlon_cor
heptathlon_cov <- cov(heptathlon[,-score])
heptathlon_cov
heptathlon_cor
heptathlon_cov
library(nutshell)
?nutshell
help
data(births2006.smpl)
dir
ls()
births2006.cln <- births2006[!is.na(births2006$WTGAIN) & !is.na(births2006$DBWT) & births2006$DPLURAL=="1 Single" & births2006$ESTGEST>35,]
births2006 <- births2006.smpl
births2006.cln <- births2006[!is.na(births2006$WTGAIN) & !is.na(births2006$DBWT) & births2006$DPLURAL=="1 Single" & births2006$ESTGEST>35,]
smoothScatter(births2006.cln$WTGAIN,births2006.cln$DBWT)
library(nutshell)#
data(births2006.smpl)#
births2006 <- births2006.smpl#
births2006.cln <- births2006[!is.na(births2006$WTGAIN) & !is.na(births2006$DBWT) & births2006$DPLURAL=="1 Single" & births2006$ESTGEST>35,]#
smoothScatter(births2006.cln$WTGAIN,births2006.cln$DBWT)
x <-(seq(1:6),ncol=2)
x <-(seq(1:6),col=2)
x <-seq(1:6)
x.col <-2
x
rm(x.col)
x.ncol() <-2
x
?
)
x
reshape(x,ncol=2)
?reshape
x <- matrix(x,ncol=2)
x
a <- R.Version
a$os
a
a <- R.Version()
a$os
b<-a$os[1:3]
b
b<-a$os[1][1:3]
b
b<-as.character(a$os)
b
b[1]
y=rnorm(1000,17,3)#
hist(y)#
qqnorm(y)#
qqline(y,col="green")
shapiro.test(y)
library(nortest)#
ad.test(y)
?rnorm
generate normally distributed data#
y=rnorm(10000,17,3)#
hist(y)#
qqnorm(y)#
qqline(y,col="green")#
#
## perform the Shapiro-Wilks test#
shapiro.test(y)
generate normally distributed data#
y=rnorm(4500,17,3)#
hist(y)#
qqnorm(y)#
qqline(y,col="green")#
#
## perform the Shapiro-Wilks test#
shapiro.test(y)
y=rnorm(500,17,3)#
hist(y)#
qqnorm(y)#
qqline(y,col="green")#
#
## perform the Shapiro-Wilks test#
shapiro.test(y)
?shapiro.test
shapiro.test(rnorm(100, mean = 5, sd = 3))
shapiro.test(rnorm(1000, mean = 17.0, sd = 3.0))
y <- rnorm(1000, mean = 17.0, sd = 3.0)
hist(y)
qqline(y,col="red")
qqplot(y)
generate normally distributed data#
y=rnorm(4500,17,3)#
hist(y)#
qqnorm(y)#
qqline(y,col="green")#
#
## perform the Shapiro-Wilks te
qqnorm(y)
qqline(y,col="red")
shapiro.test(y)
set.seed(2)
y <- rnorm(1000, mean = 17.0, sd = 3.0)
shapiro.test(y)
set.seed(2)
y <- rnorm(1000, mean = 17.0, sd = 3.0)
shapiro.test(y)
ad.test(y)
?rasclass
help
kelp()
help()
library(rasclass)
For this example, create artificial data#
mysample <- c(rep(rep(c(1,2), each = 25), 25), rep(rep(c(3,4), each = 25), 25))#
mysample <- mysample + sample(c(0, NA), 2500, replace = TRUE, prob = c(1, 10))#
myvar1 <- rep(1:50, each = 50) + rnorm(2500, 0, 5)#
myvar2 <- rep(rep(1:50), 50) + rnorm(2500, 0, 5)#
newdata <- data.frame(mysample, myvar1, myvar2)#
#
# Prepare a rasclass object using the dataframe and specifying raster properties#
object <- new('rasclass')#
object <- setRasclassData(newdata, ncols = 50, nrows = 50,#
	xllcorner = 0, yllcorner = 0, cellsize = 1, NAvalue = -9999,#
	samplename = 'mysample')#
#
# Classify using each algorithm once#
outlist <- list()#
outlist[['maximumLikelihood']] <- classifyRasclass(object, method = 'maximumLikelihood')#
summary(outlist[['maximumLikelihood']])#
#
outlist[['logit']] <- classifyRasclass(object, method = 'logit')#
summary(outlist[['logit']])#
#
outlist[['neuralNetwork']] <- classifyRasclass(object, method = 'neuralNetwork')#
summary(outlist[['neuralNetwork']])#
#
outlist[['randomForest']] <- classifyRasclass(object, method = 'randomForest')#
summary(outlist[['randomForest']])#
#
outlist[['supportVector']] <- classifyRasclass(object, method = 'supportVector')#
summary(outlist[['supportVector']])#
#
# Store sample data as a rasclassRaster for display purposes#
mysample.ras <- new('rasclassRaster')#
mysample.ras@grid <- mysample#
mysample.ras@nrows <- 50#
mysample.ras@ncols <- 50#
mysample.ras@xllcorner <- 0#
mysample.ras@yllcorner <- 0#
mysample.ras@cellsize <- 1#
mysample.ras@NAvalue <- -9999#
#
# Plot results of each classifier#
opar <- par(mfrow = c(2, 3))#
image(mysample.ras)#
title('Sample data')#
for(i in 1:length(outlist)) {#
	image(outlist[[i]]@predictedGrid)#
	title(names(outlist)[[i]])#
}#
par(opar)
mysample.ras
image(# For this example, create artificial data#
mysample <- c(rep(rep(c(1,2), each = 25), 25), rep(rep(c(3,4), each = 25), 25))#
mysample <- mysample + sample(c(0, NA), 2500, replace = TRUE, prob = c(1, 10))#
myvar1 <- rep(1:50, each = 50) + rnorm(2500, 0, 5)#
myvar2 <- rep(rep(1:50), 50) + rnorm(2500, 0, 5)#
newdata <- data.frame(mysample, myvar1, myvar2)#
#
# Prepare a rasclass object using the dataframe and specifying raster properties#
object <- new('rasclass')#
object <- setRasclassData(newdata, ncols = 50, nrows = 50,#
	xllcorner = 0, yllcorner = 0, cellsize = 1, NAvalue = -9999,#
	samplename = 'mysample')#
#
# Classify using each algorithm once#
outlist <- list()#
outlist[['maximumLikelihood']] <- classifyRasclass(object, method = 'maximumLikelihood')#
summary(outlist[['maximumLikelihood']])#
#
outlist[['logit']] <- classifyRasclass(object, method = 'logit')#
summary(outlist[['logit']])#
#
outlist[['neuralNetwork']] <- classifyRasclass(object, method = 'neuralNetwork')#
summary(outlist[['neuralNetwork']])#
#
outlist[['randomForest']] <- classifyRasclass(object, method = 'randomForest')#
summary(outlist[['randomForest']])#
#
outlist[['supportVector']] <- classifyRasclass(object, method = 'supportVector')#
summary(outlist[['supportVector']])#
#
# Store sample data as a rasclassRaster for display purposes#
mysample.ras <- new('rasclassRaster')#
mysample.ras@grid <- mysample#
mysample.ras@nrows <- 50#
mysample.ras@ncols <- 50#
mysample.ras@xllcorner <- 0#
mysample.ras@yllcorner <- 0#
mysample.ras@cellsize <- 1#
mysample.ras@NAvalue <- -9999#
#
# Plot results of each classifier#
opar <- par(mfrow = c(2, 3))#
image(mysample.ras)#
title('Sample data')#
for(i in 1:length(outlist)) {#
	image(outlist[[i]]@predictedGrid)#
	title(names(outlist)[[i]])#
}#
par(opar)#
)
image(mysample.ras)
update.packages(ask=F)
dat = read.table('http://waage.sr.unh.edu/~braswell/eos864/data/enso_mei.csv',sep=',',header=T)#
dat = reshape(dat, varying=list(2:13), direction="long")#
ord = order(dat[,1], dat[,2])#
mei = na.omit(dat[ord,3])#
mei = ts(mei, freq=12, start=c(1950,1))#
#
t = time(mei)
curve = function(t,a,b,c,d,e) {#
  #p[1] + p[2]*t + p[3]*sin(2*pi*(t-p[4])/p[5])#
  a + b*t + c*sin(2*pi*(t-d)/e)#
}#
#
#p0 = c(-25.8, .013, 2., 0., 5.)#
#
p0 = list(a = -25.8, b=0.013, c=2.0, d=0.0, e=5.0)
mod = nls(mei ~ a + b*t + c*sin(2*pi*(t-d)/e),#
      start=list(a = -25.8, b=0.013, c=2.0, d=0.0, e=5.0))#
#
pred = ts(predict(mod),  freq=12, start=c(1950,1))#
#
c = coef(mod)#
#
mod = nls(mei ~ a + b*t + c*sin(2*pi*(t-d)/e) + f*sin(2*pi*(t-g)/h),#
      start=list(a = c[1], b=c[2], c=c[3], d=c[4], e=c[5], f=1, g=0., h=4.))#
pred = ts(predict(mod),  freq=12, start=c(1950,1))#
#
plot(mei)#
lines(pred,col='red',lwd=2)
c = coef(mod)#
#
mod = nls(mei ~ a + b*t + c*sin(2*pi*(t-d)/e) + f*sin(2*pi*(t-g)/h) + j*sin(2*pi*(t-k)/l),#
      start=list(a = c[1], b=c[2], c=c[3], d=c[4], e=c[5], f=c[6], g=c[7], h=c[8],#
      j=1., k=0., l=6))#
#
pred = ts(predict(mod),  freq=12, start=c(1950,1))#
#
plot(mei)#
lines(pred,col='red',lwd=2)
c = coef(mod)#
#
mod = nls(mei ~ a + b*t + c*sin(2*pi*(t-d)/e) + f*sin(2*pi*(t-g)/h) + j*sin(2*pi*(t-k)/l)#
      + m*sin(2*pi*(t-n)/o),#
      start=list(a = c[1], b=c[2], c=c[3], d=c[4], e=c[5], f=c[6], g=c[7], h=c[8],#
      j=c[9], k=c[10], l=c[11],#
      m=1., n=0., o=6))#
pred = ts(predict(mod),  freq=12, start=c(1950,1))#
#
plot(mei)#
lines(pred,col='red',lwd=2)
c = coef(mod)#
#
mod = nls(mei ~ a + b*t + c*sin(2*pi*(t-d)/e) + f*sin(2*pi*(t-g)/h) + j*sin(2*pi*(t-k)/l)#
      + m*sin(2*pi*(t-n)/o) + p*sin(2*pi*(t-q)/r),#
      start=list(a = c[1], b=c[2], c=c[3], d=c[4], e=c[5], f=c[6], g=c[7], h=c[8],#
      j=c[9], k=c[10], l=c[11], m=c[12], n=c[13], o=c[14],#
      p=1., q=0., r=6))#
#
pred = ts(predict(mod),  freq=12, start=c(1950,1))#
#
plot(mei)#
lines(pred,col='red',lwd=2)
library(car)#
#
x=seq(100)#
#
y=x+20*rnorm(100)#
#
plot(x,y)#
#
m=lm(y~x)#
#
shapiro.test(resid(m))#
outlier.test(m)#
#
y[50]=150#
#
m=lm(y~x)#
#
shapiro.test(resid(m))#
outlier.test(m)
dir = 'http://waage.sr.unh.edu/~braswell/eos864/data/'#
file = 'aviris_N_cal_full_spectrum.csv'#
aviris = read.table(paste(dir,file,sep=''),sep=',',header=T)
spectra = aviris[,5:189]#
dim(spectra)
matplot(t(spectra),type='l')
?t
spectra = spectra[,seq(1,185,by=3)]#
dim(spectra)#
matplot(t(spectra),type='l')
pca = princomp(spectra)
class(pca)
mode(pca)
names(pca)
pca$loadings[,1:4]
barplot(pca$sdev)
t <- 64*60+7
t
tc <- t*6.4/6.08
tc
tcm <- tc/60
tcm
half.size.px <- 5
x <- seq(from=-half.size.px, to=half.size.px,by=1)
x
source("/Users/jrminter/work/R/DoG/DoG.R")
pi*(50/2)^2
install.packages(c("car","quantreg","sm"), dependencies = TRUE)
install.packages(c("qAnalyst","qcc","IQCC"), dependencies = TRUE)#
install.packages(c("chemCal","DAAG","diffractometry","fftw","fitdistrplus","histogram","HSAUR2"), dependencies = TRUE)
install.packages(c("moments","spc"), dependencies = TRUE)#
install.packages(c("xlsx"), dependencies = TRUE)#
install.packages(c("Hmisc"), dependencies = TRUE)#
install.packages(c("xtable"), dependencies = TRUE)#
install.packages(c("fgui"), dependencies = TRUE)
install.packages(c("rcdk","rpubchem"), dependencies = TRUE)#
install.packages(c("gtools","randomForest","itertools"), dependencies = TRUE)
install.packages(c("RMySQL"), dependencies = TRUE)
install.packages("RXKCD", repos="http://R-Forge.R-project.org",type="source")
install.packages(c("RJSONIO","ReadImages"), dependencies = TRUE)
install.packages("RXKCD", repos="http://R-Forge.R-project.org",type="source")
install.packages(c("quantmod","PerformanceAnalytics"),dependencies=T)
library(RXKCD)searchXKCD("support")
library(RXKCD)
searchXKCD("support")
library(RXKCD)
searchXKCD("support")
searchXKCD("foo")
library(RXKCD)
searchXKCD("support")
help(RXKCD)
help
searchXKCD(which="someone is wrong")
help install.packages()
install.packages("/Users/jrminter/Downloads/RImageJ_0.3-144.tar.gz", repos = NULL, type='source')
logo <- system.file("images", "R.jpg", package = "RImageJ")#
image <- IJ$openImage(logo)#
image$show()
library(RImageJ)
logo <- system.file("images", "R.jpg", package = "RImageJ")#
image <- IJ$openImage(logo)#
image$show()
install.packages("/Users/jrminter/Downloads/RImageJ_0.3-144.tar.gz", repos = NULL, type='source')
Sys.setenv(NOAWT=1)
library(RImageJ)
logo <- system.file("images", "R.jpg", package = "RImageJ")#
image <- IJ$openImage(logo)#
image$show()
Sys.setenv(NOAWT=0)
logo <- system.file("images", "R.jpg", package = "RImageJ")#
image <- IJ$openImage(logo)#
image$show()
library(RImageJ)
image <- IJ$openImage(logo)
image$show()
library(RImageJ)#
logo <- system.file("images", "R.jpg", package = "RImageJ")#
image <- IJ$openImage(logo)#
image$show()
Sys.setenv(NOAWT=1) #
library(RImageJ)#
Sys.unsetenv("NOAWT")#
logo <- system.file("images", "R.jpg", package = "RImageJ")#
image <- IJ$openImage(logo)#
image$show()
library(rJava)#
Sys.setenv(NOAWT=1) #
library(RImageJ)#
Sys.unsetenv("NOAWT")#
logo <- system.file("images", "R.jpg", package = "RImageJ")#
image <- IJ$openImage(logo)#
image$show()
library(rAnaLib)
install.packages("/Users/jrminter/src/R/rAnaLab_1.1.tar.gz", repos = NULL, type='source')
quit
quit()
library(rAnaLab)
ax <- c(1.00, 2.00, 3.00, 4.00, 5.00)#
ay <- c(1.05, 2.05, 2.95, 4.05, 4.95)#
ad <- c(0.05, 0.03, 0.04, 0.06, 0.05)#
# do a plot and regression with error bars#
the.fit <- ralScatterPlotLine(ax, ay, ad, bReg=TRUE, bErrorBars=TRUE)
install.packages(c("rj", "rj.gd"), repos="http://download.walware.de/rj-1.1")
source("/Users/jrminter/git/OSImageAnalysis/R/ekPension.R")
source("/Users/jrminter/git/OSImageAnalysis/ekPension/R/ekPension.R")
